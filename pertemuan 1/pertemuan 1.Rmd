---
title: "Pert 1"
author: "Adisti Suci Rahmah G1401211027"
date: "2023-12-17"
output: html_document
---

---
title: "PRAK SESI UTS'"
author: "Adisti Suci Rahmah"
date: "2023-09-04"
output: html_document
---

```{r}
library("forecast")
library("graphics")
library("TTR")
library("TSA")
```

```{r}

library("rio")
data1 <- import("https://raw.githubusercontent.com/adistisucirahmah/mpdw/main/praktikum/datahujan.csv")
data1
```
```{r}

## Eksplorasi Data

View(data1)
str(data1)
dim(data1)
```
```{r}
##Mengubah data agar terbaca sebagai data deret waktu dengan fungsi `ts()` .

data1.ts <- ts(data1$total_rainfall)
data1.ts
```
```{r}
##Menampilkan ringkasan data

summary(data1.ts)
```
```{r}
###Membuat plot data deret waktu

ts.plot(data1.ts, xlab="Time Period ", ylab="total_rainfall", 
        main = "Time Series Plot")
points(data1.ts)
```
```{r}
#menyimpan plot
#dev.copy(png, "eksplorasi.png")
#dev.off()
```

## Single Exponential Smoothing & Double Exponential Smoothing

Metode *Exponential Smoothing* adalah metode pemulusan dengan melakukan pembobotan menurun secara eksponensial. Nilai yang lebih baru diberi bobot yang lebih besar dari nilai terdahulu. Terdapat satu atau lebih parameter pemulusan yang ditentukan secara eksplisit, dan hasil pemilihan parameter tersebut akan menentukan bobot yang akan diberikan pada nilai pengamatan. Ada dua macam model, yaitu model tunggal dan ganda.

### Pembagian Data

Pembagian data latih dan data uji dilakukan dengan perbandingan 80% data latih dan 20% data uji.

```{r}
#membagi training dan testing
training<-data1[1:188,]
training
testing<-data1[189:235,]
testing
train.ts <- ts(training$total_rainfall)
train.ts
test.ts <- ts(testing$total_rainfall)
test.ts
```

### Eksplorasi

Eksplorasi dilakukan dengan membuat plot data deret waktu untuk keseluruhan data, data latih, dan data uji.

```{r}
#eksplorasi data
plot(data1.ts, col="black",main="Plot semua data")
points(data1.ts)

plot(train.ts, col="red",main="Plot data latih")
points(train.ts)

plot(test.ts, col="blue",main="Plot data uji")
points(test.ts)
```


### SES

Single Exponential Smoothing merupakan metode pemulusan yang tepat digunakan untuk data dengan pola stasioner atau konstan.

Nilai pemulusan pada periode ke-t didapat dari persamaan:

$$
\tilde{y}_T=\lambda y_t+(1-\lambda)\tilde{y}_{T-1}
$$

Nilai parameter $\lambda$ adalah nilai antara 0 dan 1.

Nilai pemulusan periode ke-t bertindak sebagai nilai ramalan pada periode ke-$(T+\tau)$.

$$
\tilde{y}_{T+\tau}(T)=\tilde{y}_T
$$

Pemulusan dengan metode SES dapat dilakukan dengan dua fungsi dari *packages* berbeda, yaitu (1) fungsi `ses()` dari *packages* `forecast` dan (2) fungsi `HoltWinters` dari *packages* `stats` .

```{r}

#Cara 1 (fungsi ses)
ses.1 <- ses(train.ts, h = 47, alpha = 0.2)
plot(ses.1)
ses.1

ses.2<- ses(train.ts, h = 47, alpha = 0.7)
plot(ses.2)
ses.2
```

Untuk mendapatkan gambar hasil pemulusan pada data latih dengan fungsi `ses()` , perlu digunakan fungsi `autoplot()` dan `autolayer()` dari *library packages* `ggplot2` .

```{r}
library(ggplot2)
autoplot(ses.1) +
  autolayer(fitted(ses.1), series="Fitted") +
  ylab("Curah Hujan") + xlab("Periode")
```

Pada fungsi `ses()` , terdapat beberapa argumen yang umum digunakan, yaitu nilia `y` , `gamma` , `beta` , `alpha` , dan `h` .

Nilai `y` adalah nilai data deret waktu, `gamma` adalah parameter pemulusan untuk komponen musiman, `beta` adalah parameter pemulusan untuk tren, dan `alpha` adalah parameter pemulusan untuk stasioner, serta `h` adalah banyaknya periode yang akan diramalkan.

Kasus di atas merupakan contoh inisialisasi nilai parameter $\lambda$ dengan nilai `alpha` 0,2 dan 0,7 dan banyak periode data yang akan diramalkan adalah sebanyak 10 periode. Selanjutnya akan digunakan fungsi `HoltWinters()` dengan nilai inisialisasi parameter dan panjang periode peramalan yang sama dengan fungsi `ses()` .

```{r}

#Cara 2 (fungsi Holtwinter)
ses1<- HoltWinters(train.ts, gamma = FALSE, beta = FALSE, alpha = 0.2)
plot(ses1)

#ramalan
ramalan1<- forecast(ses1, h=47)
ramalan1

ses2<- HoltWinters(train.ts, gamma = FALSE, beta = FALSE, alpha = 0.7)
plot(ses2)

#ramalan
ramalan2<- forecast(ses2, h=47)
ramalan2
```

Fungsi `HoltWinters` memiliki argumen yang sama dengan fungsi `ses()` . Argumen-argumen kedua fungsi dapat dilihat lebih lanjut dengan `?ses()` atau `?HoltWinters` .

Nilai parameter $\alpha$ dari kedua fungsi dapat dioptimalkan menyesuaikan dari *error*-nya paling minimumnya. Caranya adalah dengan membuat parameter $\alpha =$ `NULL` .

```{r}

#SES
ses.opt <- ses(train.ts, h = 47, alpha = NULL)
plot(ses.opt)
ses.opt

#Lamda Optimum Holt Winter
sesopt<- HoltWinters(train.ts, gamma = FALSE, beta = FALSE,alpha = NULL)
sesopt
plot(sesopt)

#ramalan
ramalanopt<- forecast(sesopt, h=47)
ramalanopt
```

Setelah dilakukan peramalan, akan dilakukan perhitungan keakuratan hasil peramalan. Perhitungan akurasi ini dilakukan baik pada data latih dan data uji.

#### Akurasi Data Latih

Perhitungan akurasi data dapat dilakukan dengan cara langsung maupun manual. Secara langsung, nilai akurasi dapat diambil dari objek yang tersimpan pada hasil SES, yaitu *sum of squared errors* (SSE). Nilai akurasi lain dapat dihitung pula dari nilai SSE tersebut.

```{r}

#Keakuratan Metode
#Pada data training
SSE1<-ses1$SSE
MSE1<-ses1$SSE/length(train.ts)
RMSE1<-sqrt(MSE1)

akurasi1 <- matrix(c(SSE1,MSE1,RMSE1))
row.names(akurasi1)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1) <- c("Akurasi lamda=0.2")
akurasi1

SSE2<-ses2$SSE
MSE2<-ses2$SSE/length(train.ts)
RMSE2<-sqrt(MSE2)

akurasi2 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi2)<- c("SSE", "MSE", "RMSE")
colnames(akurasi2) <- c("Akurasi lamda=0.7")
akurasi2

#Cara Manual
fitted1<-ramalan1$fitted
sisaan1<-ramalan1$residuals
head(sisaan1)

resid1<-training$total_rainfall-ramalan1$fitted
head(resid1)
```

```{r}

#Cara Manual
SSE.1=sum(sisaan1[2:length(train.ts)]^2)
SSE.1

MSE.1 = SSE.1/length(train.ts)
MSE.1

MAPE.1 = sum(abs(sisaan1[2:length(train.ts)]/train.ts[2:length(train.ts)])*
               100)/length(train.ts)
MAPE.1

akurasi.1 <- matrix(c(SSE.1,MSE.1,MAPE.1))
row.names(akurasi.1)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.1) <- c("Akurasi lamda=0.2")
akurasi.1

fitted2<-ramalan2$fitted
sisaan2<-ramalan2$residuals
head(sisaan2)

resid2<-training$total_rainfall-ramalan2$fitted
head(resid2)

SSE.2=sum(sisaan2[2:length(train.ts)]^2)
SSE.2

MSE.2 = SSE.2/length(train.ts)
MSE.2

MAPE.2 = sum(abs(sisaan2[2:length(train.ts)]/train.ts[2:length(train.ts)])*
               100)/length(train.ts)
MAPE.2

akurasi.2 <- matrix(c(SSE.2,MSE.2,MAPE.2))
row.names(akurasi.2)<- c("SSE", "MSE", "MAPE")
colnames(akurasi.2) <- c("Akurasi lamda=0.7")
akurasi.2
```

Berdasarkan nilai SSE, MSE, RMSE, dan MAPE di antara kedua parameter, nilai parameter $\lambda=0,2$ menghasilkan akurasi yang lebih baik dibanding $\lambda=0,7$ . Hal ini dilihat dari nilai masing-masing ukuran akurasi yang lebih kecil. Berdasarkan nilai MAPE-nya, hasil ini dapat dikategorikan sebagai peramalan sangat baik.

#### Akurasi Data Uji

Akurasi data uji dapat dihitung dengan cara yang hampir sama dengan perhitungan akurasi data latih.

```{r}

selisih1<-ramalan1$mean-testing$total_rainfall
SSEtesting1<-sum(selisih1^2)
MSEtesting1<-SSEtesting1/length(testing)


selisih2<-ramalan2$mean-testing$total_rainfall
SSEtesting2<-sum(selisih2^2)
MSEtesting2<-SSEtesting2/length(testing)

selisihopt<-ramalanopt$mean-testing$total_rainfall
SSEtestingopt<-sum(selisihopt^2)
MSEtestingopt<-SSEtestingopt/length(testing)

akurasitesting1 <- matrix(c(SSEtesting1,SSEtesting2,SSEtestingopt))
row.names(akurasitesting1)<- c("SSE1", "SSE2", "SSEopt")
akurasitesting1

akurasitesting2 <- matrix(c(MSEtesting1,MSEtesting2,MSEtestingopt))
row.names(akurasitesting2)<- c("MSE1", "MSE2", "MSEopt")
akurasitesting2
```
## Pemulusan Data Musiman

Pertama impor kembali data baru untuk latihan data musiman.

```{r}
#Import data
library(rio)
data2 <- import("https://raw.githubusercontent.com/adistisucirahmah/mpdw/main/praktikum/datahujan.csv")
data2
data2.ts <- ts(data2$total_rainfall)
data2.ts
```

Selanjutnya melakukan pembagian data dan mengubahnya menjadi data deret waktu.

```{r}
#membagi data menjadi training dan testing
training<-data2[1:188,2]
training
testing<-data2[189:235,2]
testing
training.ts2<-ts(training, frequency = 13)
training.ts2
testing.ts2<-ts(testing, frequency = 13)
testing.ts2
```

Kemudian akan dilakukan eskplorasi dengan plot data deret waktu sebagai berikut.

```{r}
#Membuat plot time series
plot(data2.ts, col="red",main="Plot semua data")
points(data2.ts)

plot(training.ts2, col="blue",main="Plot data latih")
points(training.ts2)

plot(testing.ts2, col="green",main="Plot data uji")
points(testing.ts2)
```

Metode Holt-Winter untuk peramalan data musiman menggunakan tiga persamaan pemulusan yang terdiri atas persamaan untuk level $(L_t)$, trend $(B_t)$, dan komponen seasonal / musiman $(S_t)$ dengan parameter pemulusan berupa $\alpha$, $\beta$, dan $\gamma$. Metode Holt-Winter musiman terbagi menjadi dua, yaitu metode aditif dan metode multiplikatif. Perbedaan persamaan dan contoh datanya adalah sebagai berikut.

![](images/Perbandingan%20model%20aditif.png){width="609"}

![](images/example%20additive-multiplicative.png)

Pemulusan data musiman dengan metode Winter dilakukan menggunakan fungsi `HoltWinters()` dengan memasukkan argumen tambahan, yaitu `gamma()` dan `seasonal()` . Arguman `seasonal()` diinisialisasi menyesuaikan jenis musiman, aditif atau multiplikatif.

### Winter Aditif

Perhitungan dengan model aditif dilakukan jika plot data asli menunjukkan fluktuasi musiman yang relatif stabil (konstan).

#### Pemulusan

```{r}
#Pemulusan dengan winter aditif 
winter1 <- HoltWinters(training.ts2,alpha=0.2,beta=0.1,gamma=0.1,seasonal = "additive")
winter1$fitted
xhat1 <- winter1$fitted[,2]

winter1.opt<- HoltWinters(training.ts2, alpha= NULL,  beta = NULL, gamma = NULL, seasonal = "additive")
winter1.opt
winter1.opt$fitted
xhat1.opt <- winter1.opt$fitted[,2]
```

#### Peramalan

```{r}
#Forecast
forecast1 <- predict(winter1, n.ahead = 47)
forecast1.opt <- predict(winter1.opt, n.ahead = 47)
```

#### Plot Deret Waktu

```{r}
#Plot time series
plot(training.ts2,main="Winter 0.2;0.1;0.1",type="l",col="black",
     xlim=c(1,25),pch=12)
lines(xhat1,type="l",col="red")
lines(xhat1.opt,type="l",col="blue")
lines(forecast1,type="l",col="red")
lines(forecast1.opt,type="l",col="blue")
legend("topleft",c("Actual Data",expression(paste(winter1)),
                   expression(paste(winter1.opt))),cex=0.5,
       col=c("black","red","blue"),lty=1)
```

#### Akurasi Data Latih

```{r}
#Akurasi data training
SSE1<-winter1$SSE
MSE1<-winter1$SSE/length(training.ts2)
RMSE1<-sqrt(MSE1)
akurasi1 <- matrix(c(SSE1,MSE1,RMSE1))
row.names(akurasi1)<- c("SSE", "MSE", "RMSE")
colnames(akurasi1) <- c("Akurasi")
akurasi1

SSE1.opt<-winter1.opt$SSE
MSE1.opt<-winter1.opt$SSE/length(training.ts2)
RMSE1.opt<-sqrt(MSE1.opt)
akurasi1.opt <- matrix(c(SSE1.opt,MSE1.opt,RMSE1.opt))
row.names(akurasi1.opt)<- c("SSE1.opt", "MSE1.opt", "RMSE1.opt")
colnames(akurasi1.opt) <- c("Akurasi")
akurasi1.opt

akurasi1.train = data.frame(Model_Winter = c("Winter 1","Winter1 optimal"),
                            Nilai_SSE=c(SSE1,SSE1.opt),
                            Nilai_MSE=c(MSE1,MSE1.opt),Nilai_RMSE=c(RMSE1,RMSE1.opt))
akurasi1.train
```

#### Akurasi Data Uji

```{r}
#Akurasi Data Testing
forecast1<-data.frame(forecast1)
testing.ts2<-data.frame(testing.ts2)
selisih1<-forecast1-testing.ts2
SSEtesting1<-sum(selisih1^2)
MSEtesting1<-SSEtesting1/length(testing.ts2)

forecast1.opt<-data.frame(forecast1.opt)
selisih1.opt<-forecast1.opt-testing.ts2
SSEtesting1.opt<-sum(selisih1.opt^2)
MSEtesting1.opt<-SSEtesting1.opt/length(testing.ts2)
```

### Winter Multiplikatif

Model multiplikatif digunakan cocok digunakan jika plot data asli menunjukkan fluktuasi musiman yang bervariasi.

#### Pemulusan

```{r}
#Pemulusan dengan winter multiplikatif 
winter2 <- HoltWinters(training.ts2,alpha=0.2,beta=0.1,gamma=0.3,seasonal = "multiplicative")
winter2$fitted
xhat2 <- winter2$fitted[,2]

winter2.opt<- HoltWinters(training.ts2, alpha= NULL,  beta = NULL, gamma = NULL, seasonal = "multiplicative")
winter2.opt$fitted
xhat2.opt <- winter2.opt$fitted[,2]
```

#### Peramalan

```{r}
#Forecast
forecast2 <- predict(winter2, n.ahead = 47)
forecast2.opt <- predict(winter2.opt, n.ahead = 47)
```

#### Plot Deret Waktu

```{r}
#Plot time series
plot(training.ts2,main="Winter 0.2;0.1;0.1",type="l",col="black",
     xlim=c(1,25),pch=12)
lines(xhat2,type="l",col="red")
lines(xhat2.opt,type="l",col="blue")
lines(forecast2,type="l",col="red")
lines(forecast2.opt,type="l",col="blue")
legend("topleft",c("Actual Data",expression(paste(winter2)),
                   expression(paste(winter2.opt))),cex=0.5,
       col=c("black","red","blue"),lty=1)
```

#### Akurasi Data Latih

```{r}
#Akurasi data training
SSE2<-winter2$SSE
MSE2<-winter2$SSE/length(training.ts2)
RMSE2<-sqrt(MSE2)
akurasi1 <- matrix(c(SSE2,MSE2,RMSE2))
row.names(akurasi1)<- c("SSE2", "MSE2", "RMSE2")
colnames(akurasi1) <- c("Akurasi lamda=0.2")
akurasi1

SSE2.opt<-winter2.opt$SSE
MSE2.opt<-winter2.opt$SSE/length(training.ts2)
RMSE2.opt<-sqrt(MSE2.opt)
akurasi1.opt <- matrix(c(SSE2.opt,MSE2.opt,RMSE2.opt))
row.names(akurasi1.opt)<- c("SSE2.opt", "MSE2.opt", "RMSE2.opt")
colnames(akurasi1.opt) <- c("Akurasi")
akurasi1.opt

akurasi2.train = data.frame(Model_Winter = c("Winter 1","winter2 optimal"),
                            Nilai_SSE=c(SSE2,SSE2.opt),
                            Nilai_MSE=c(MSE2,MSE2.opt),Nilai_RMSE=c(RMSE2,RMSE2.opt))
akurasi2.train
```

#### Akurasi Data Uji

```{r}

#Akurasi Data Testing
forecast2<-data.frame(forecast2)
testing.ts2<-data.frame(testing.ts2)
selisih2<-forecast2-testing.ts2
SSEtesting2<-sum(selisih2^2)
MSEtesting2<-SSEtesting2/length(testing.ts2)

forecast2.opt<-data.frame(forecast2.opt)
selisih2.opt<-forecast2.opt-testing.ts2
SSEtesting2.opt<-sum(selisih2.opt^2)
MSEtesting2.opt<-SSEtesting2.opt/length(testing.ts2)
```



